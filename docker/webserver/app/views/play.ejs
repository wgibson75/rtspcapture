<html>
  <head>
    <title>HD Playback</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link href="/css/play.css" rel="stylesheet" />
    <link href="jquery-ui-1-13-2.css" rel="stylesheet">
    <script src="jquery-3.7.1.min.js"></script>
    <script src="jquery-ui-1-13-2.min.js"></script>
  </head>
  <script>
  const CAPTURE_DIR   = "<%= capture_dir %>";
  const PLAYBACK_TIME = "<%= playback_time %>";
  const CAMERA        = "<%= camera_name %>";

  const CAMERA_LIST  = [];
  CAMERA_LIST.push(<%- camera_names_list %>);

  const MARGIN_CONTROL_TOP_PCT = 5;  // Top margin of control pane as percentage of screen height
  const HEIGHT_CONTROL_PCT     = 85; // Height of control pane as percentage of screen height

  // Doesn't work for iPad unfortunately i.e. iPad reported as Mac (clearly a bug!)
  const IS_IPHONE = (/iPhone/.test(navigator.userAgent)) ? true : false;

  // Percentage height to add to top margin of control and remove from
  // height of control for iPhone when orientation is portrait
  const IPHONE_HEIGHT_DELTA_CONTROL_PCT = 35;

  var RECORDINGS = null; // Set to Recordings object to manage recordings data
  var PLAYBACK   = null; // Set to Playback object to control video playback operations
  var CONTROL   = null;  // Set to Control object to render control panel for controlling playback

  var KEYS_DOWN = {}; // Stores a dictionary of keypresses that are currently occuring


  ////
  // Classes
  ////////

  class Recordings {
    #captureDir      = null; // Capture directory
    #camera          = null; // Camera name
    #cameraList      = null;
    #loadedCbs       = [];   // List of callbacks to notify when recordings loaded
    #recordings      = [];   // Recordings in reverse chronological order (including non playable live first)
    #dayBoundaryIdxs = [];   // List of day boundary indexes i.e. indexes of first recording in each day

    constructor(camera, cameraList, captureDir) {
      // Trigger loading recordings for this camera
      this.setCamera(camera);

      this.#cameraList = cameraList;
      this.#captureDir = captureDir;
    }

    #loadRecordings() {
      fetch(`/recordings?c=${this.#camera}`)
        .then((response) => {
          if (response.ok) return response.json();
        })
        .then((json) => {
          if (!json) return;

          this.#recordings = []; // Empty all existing recordings entries

          for (let i = 0, currentDay = null; i < json.recordings.length; i++) {
            let [file, crtime] = json.recordings[i];

            let dateObj = new Date(crtime * 1000);
            let year  = dateObj.getFullYear();
            let month = dateObj.getMonth();
            let date  = dateObj.getDate();
            let day   = dateObj.getDay();
            let hrs   = dateObj.getHours();
            let mins  = dateObj.getMinutes();
            let secs  = dateObj.getSeconds();

            if (currentDay != day) {
              if (currentDay != null) {
                this.#dayBoundaryIdxs.push(i);
              }
              currentDay = day;
            }
            this.#recordings.push([file, crtime, year, month, date, day, hrs, mins, secs]);
          }
          // Call loaded callbacks
          for (const callback of this.#loadedCbs) callback();
        });
    }

    setLoadedCb(callback) {
      this.#loadedCbs.push(callback);
    }

    setCamera(camera) {
      this.#camera = camera;
      this.#loadRecordings();
    }

    prevCamera() {
      let idx = this.#cameraList.indexOf(this.#camera);
      if ((idx == -1) || (idx == 0)) return false;

      this.setCamera(this.#cameraList[--idx]);
      return true;
    }

    nextCamera() {
      let idx = this.#cameraList.indexOf(this.#camera);
      if ((idx == -1) || (idx == (this.#cameraList.length - 1))) return false;

      this.setCamera(this.#cameraList[++idx]);
      return true;
    }

    getNumRecordings() {
      return this.#recordings.length;
    }

    getDayBoundaryIndexes() {
      return this.#dayBoundaryIdxs;
    }

    getDateFields(idx) {
      if ((idx < 0) || (idx >= this.#recordings.length)) return;

      return this.#recordings[idx].slice(2); // Return only date related fields
    }

    getPlayUrl(idx) {
      if ((idx < 0) || (idx >= this.#recordings.length)) return;

      // Return the live stream URL for first recording or playback URL otherwise
      return (idx == 0)
        ? `/${CAPTURE_DIR}/${this.#camera}/high_res/live.m3u8`
        : `/${CAPTURE_DIR}/${this.#camera}/${this.#recordings[idx][0]}`;
    }

    getIdxAndOffsetForTime(t) {
      for (let i = 0; i < this.#recordings.length; i++) {
        let [file, crtime, year, month, date, day, hrs, mins, secs] = this.#recordings[i];

        if (t >= crtime) {
          let offset = t - crtime; // Position must be in seconds
          return [i, offset];
          break;
        }
      }
      return undefined;
    }

    getStartTimeEpochSecs(idx) {
      if ((idx < 0) || (idx >= this.#recordings.length)) return;

      let [file, crtime, year, month, date, day, hrs, mins, secs] = this.#recordings[idx];
      return crtime;
    }
  }

  class Playback {
    #SPEEDS           = [0, 0.5, 1, 2, 4, 8, 16]; // Supported playback speeds
    #NORMAL_SPEED_IDX = 2;                        // Index of normal playback speed
    #PAUSED_SPEED_IDX = 0;                        // Index of paused playback speed
    #SEEK_TIME_SECS   = 30;                       // Seek time in seconds

    #video      = null;
    #recordings = null;
    #control    = null;
    #url        = null;
    #speedIdx   = this.#NORMAL_SPEED_IDX;
    #isPaused   = null;

    #sameSpeedForNextPlay = false;

    constructor(videoElementId, recsObj) {
      this.#video      = document.getElementById(videoElementId);
      this.#recordings = recsObj;

      this.#video.addEventListener("canplay", e => {
        $("#video").show();
      });

      this.#video.addEventListener("ended", e => {
        if (this.#control != null) {
          let currentPlayIdx = this.#control.getCurrentPlayIdx();
          $(`#${currentPlayIdx - 1}`).click(); // Play next video when current ends
        }
      });
    }

    setControl(controlObj) {
      this.#control = controlObj;
    }

    play(url) {
      if (!url) return false;

      this.#url = url;
      this.#isPaused = false;
      this.#video.src = url;
      this.#video.playbackRate = this.#SPEEDS[this.#speedIdx];

      return true;
    }

    togglePlayPause() {
      if (!this.#url) return false;

      if (this.#isPaused) {
        this.#video.play();
        this.#isPaused = false;
      }
      else {
        this.#video.pause()
        this.#isPaused = true;
      }
      return true;
    }

    isPaused() {
      return this.#isPaused;
    }

    speedUp() {
      if (!this.#url) return false;                        // Ignore if not playing anything
      if ((this.#speedIdx == (this.#SPEEDS.length - 1)) && // Ignore if already at max speed
          !this.#isPaused) return false;                   // and not paused

      if (this.#isPaused) this.#speedIdx = this.#PAUSED_SPEED_IDX; // Set speed index to stopped if paused
      this.#video.playbackRate = this.#SPEEDS[++this.#speedIdx];   // Set the incremented playback rate
      if (this.#isPaused) this.togglePlayPause();                  // Toggle playback to commence if paused

      return true;
    }

    speedDown() {
      if (!this.#url) return false;          // Ignore if not playing anything
      if (this.#speedIdx == 0) return false; // Ignore if already at min speed

      this.#video.playbackRate = this.#SPEEDS[--this.#speedIdx]; // Set the decremented playback rate
      if (this.#isPaused) this.togglePlayPause();                // Toggle playback to commence if paused

      return true;
    }

    seekForward() {
      // Let player handle if we go forward too far
      this.#video.currentTime += this.#SEEK_TIME_SECS;
    }

    seekBack() {
      // Let player handle if we go backward too far
      this.#video.currentTime -= this.#SEEK_TIME_SECS;
    }

    setPosition(position) {
      this.#video.currentTime = position;
    }

    getPosition() {
      return this.#video.currentTime;
    }

    getStatusString() {
      return (this.#isPaused) ? "Paused" : `x${this.#SPEEDS[this.#speedIdx]}`;
    }
  }

  class Control {
    #LIVE_PLAY_ID                   = 0;    // ID of live playback stream
    #BUTTON_PRESS_HIGHLIGHT_TIME_MS = 500;  // Duration of button highlight when pressed
    #DAYS                           = ["Sun", "Mon", "Tue", "Wed", "Thur", "Fri", "Sat"];

    #recordings      = null;
    #playback        = null;
    #controlId       = null;
    #entriesId       = null;
    #playPauseId     = null;
    #playbackStateId = null;
    #iPhoneButtonsId = null;
    #repositionCb    = null;

    #currentPlayId      = null;
    #buttonPressTimeout = null;
    #pressedButton      = null;
    #nextPlaybackTime   = null; // Next playback time (as epoch) to use for next camera

    #isFlipped = false; // Only used for iPhone to flip positioning of control

    constructor(recsObj, playObj, controlId, entriesId, playPauseId, playStateId, iPhoneButtonsId, repositionCb) {
      this.#recordings      = recsObj;
      this.#playback        = playObj;
      this.#controlId       = controlId;
      this.#entriesId       = entriesId;
      this.#playPauseId     = playPauseId;
      this.#playbackStateId = playStateId;
      this.#iPhoneButtonsId = iPhoneButtonsId;
      this.#repositionCb    = repositionCb;

      this.#recordings.setLoadedCb(this.#recordingsLoadedCb.bind(this));
    }

    #recordingsLoadedCb() {
      this.#populate();

      if (this.#nextPlaybackTime != null) {
        // Get the entry index and offset position that matches this playback time
        let [idx, offset] = this.#recordings.getIdxAndOffsetForTime(this.#nextPlaybackTime);

        this.#scrollToEntry(idx);          // Scroll to the entry
        $(`#${idx}`).click();              // Click the entry to trigger playback
        this.#playback.setPosition(offset) // Set the playback position

        this.#nextPlaybackTime = null;
      }
      else {
        $(`#${this.#LIVE_PLAY_ID}`).click();
      }
    }

    #showPlaybackState() {
      $("#play-pause").html(this.#playback.isPaused() ? "Play" : "Pause");
      $("#play-state").html(this.#playback.getStatusString());
    }

    #showButtonPress(button) {
      if (this.#buttonPressTimeout != null) {
        clearTimeout(this.#buttonPressTimeout);
        this.#hideButtonPress(this.#pressedButton);
      }
      $(`#${button.id}`).toggleClass("button-highlight");

      this.#pressedButton      = button;
      this.#buttonPressTimeout = setTimeout(this.#hideButtonPress.bind(this), this.#BUTTON_PRESS_HIGHLIGHT_TIME_MS, button);
    }

    #hideButtonPress(button) {
      $(`#${button.id}`).toggleClass("button-highlight");

      this.#buttonPressTimeout = null;
      this.#pressedButton      = null;
    }

    #populate() {
      // Clear the control first
      $(`#${this.#entriesId}`).empty();

      // Build lookup table for indexes of recordings on day boundary
      let dayRecIdxLookup = {};
      let dayRecIdxs = this.#recordings.getDayBoundaryIndexes();
      for (let i = 0; i < dayRecIdxs.length; i++) {
        dayRecIdxLookup[dayRecIdxs[i]]++;
      }

      // Now populate all entries in the control pane showing
      for (let idx = 0; idx < this.#recordings.getNumRecordings(); idx++) {
        let [year, month, date, day, hrs, mins, secs] = this.#recordings.getDateFields(idx);

        // Format certain time fields
        date  = ("0" + date).slice(-2);
        month = ("0" + (month + 1)).slice(-2);
        hrs   = ("0" + hrs).slice(-2);
        mins  = ("0" + mins).slice(-2);
        secs  = ("0" + secs).slice(-2);

        // Show day boundary
        if (idx in dayRecIdxLookup) {
          let text = `${this.#DAYS[day]} ${date}-${month}-${year}`;
          $(`#${this.#entriesId}`).append(`<div class="entry-day-boundary">${text}</div>`);
        }

        let text = (idx== this.#LIVE_PLAY_ID) ? "Live" : `${hrs}:${mins}:${secs}`; // First entry is live

        // Use the recording index as the entry ID
        $(`#${this.#entriesId}`).append(
          `<div class="entry-playback" id="${idx}" onclick="CONTROL.play(${idx})">` +
          `  <div><hr></div><div style="flex-grow: 1">${text}</div><div><hr></div>` +
          "</div>"
        );
      }

      // Only show button for flipping position on iPhone
      if (!IS_IPHONE) $(`#${this.#iPhoneButtonsId}`).hide();

      // Now show the control pane
      $(`#${this.#controlId}`).css("display", "flex");
    }

    #getCurrentPlaybackTime() {
      let startTime = this.#recordings.getStartTimeEpochSecs(this.#currentPlayId);
      let position  = Math.round(this.#playback.getPosition())

      return startTime + position;
    }

    #scrollToEntry(idx) {
      let panel = $(`#${this.#entriesId}`);
      let entry = $(`#${idx}`);

      panel.scrollTop(entry.offset().top - panel.offset().top + panel.scrollTop());
    }

    // Note: recording index and corresponding entry ID in control pane are the same
    play(idx) {
      let url = this.#recordings.getPlayUrl(idx);
      this.#playback.play(url);

      // Handle selection highlight
      if ((this.#currentPlayId != null) && (this.#currentPlayId != idx)) {
        $(`#${this.#currentPlayId}`).removeClass("entry-playback-selected");
      }
      $("#" + idx).addClass("entry-playback-selected");
      this.#currentPlayId = idx;

      this.#showPlaybackState();
    }

    getCurrentPlayIdx() {
      return this.#currentPlayId;
    }

    isFlipped() {
      return this.#isFlipped;
    }

    togglePlayPause(button) {
      if (this.#playback.togglePlayPause()) {
        this.#showButtonPress(button);
        this.#showPlaybackState();
      }
    }

    speedUp(button) {
      if (this.#currentPlayId == this.#LIVE_PLAY_ID) return; // Do not support on live
      if (this.#playback.speedUp()) {
        this.#showButtonPress(button);
        this.#showPlaybackState();
      }
    }

    speedDown(button) {
      if (this.#currentPlayId == this.#LIVE_PLAY_ID) return; // Do not support on live
      if (this.#playback.speedDown()) {
        this.#showButtonPress(button);
        this.#showPlaybackState();
      }
    }

    prevCam(button) {
      if (!this.#recordings.prevCamera()) return;
      this.#showButtonPress(button);
      this.#nextPlaybackTime = this.#getCurrentPlaybackTime();
    }

    nextCam(button) {
      if (!this.#recordings.nextCamera()) return;
      this.#showButtonPress(button);
      this.#nextPlaybackTime = this.#getCurrentPlaybackTime();
    }

    seekForward(button) {
      if (this.#currentPlayId == this.#LIVE_PLAY_ID) return; // Do not support on live
      if (button) showButtonPress(button);
      this.#playback.seekForward();
    }

    seekBack(button) {
      if (this.#currentPlayId == this.#LIVE_PLAY_ID) return; // Do not support on live
      if (button) this.#showButtonPress(button);
      this.#playback.seekBack();
    }

    reposition(button) {
      this.#showButtonPress(button);
      this.#isFlipped = !this.#isFlipped;
      this.#repositionCb(false, false, this.#isFlipped);
    }
  }

  ////
  // Utility functions
  ////////

  $(document).ready(function () {
    // Make the control draggable on supported devices
    $(function() {
      $("#control").draggable();
    });

    RECORDINGS = new Recordings(CAMERA, CAMERA_LIST, CAPTURE_DIR);
    PLAYBACK   = new Playback("video", RECORDINGS);
    CONTROL    = new Control(RECORDINGS, PLAYBACK, "control", "entries", "play-pause", "play-state", "iphone-buttons", positionControl);

    positionControl(false, false, CONTROL.isFlipped());
    PLAYBACK.setControl(CONTROL);

    resizeVideo();
  });

  function isIphonePortrait() {
    return (IS_IPHONE && (screen.orientation.type == "portrait-primary"));
  }

  function resizeVideo() {
    video.setAttribute("width", window.innerWidth);
  }

  function positionControl(isResize, isOrientationChange, isFlipped) {
    let height = isIphonePortrait()
      ? HEIGHT_CONTROL_PCT - IPHONE_HEIGHT_DELTA_CONTROL_PCT
      : HEIGHT_CONTROL_PCT;

    let top = isIphonePortrait()
      ? MARGIN_CONTROL_TOP_PCT + IPHONE_HEIGHT_DELTA_CONTROL_PCT
      : MARGIN_CONTROL_TOP_PCT;

    $("#control").css("height", `${height}%`);
    $("#control").css("top", `${top}%`);

    if (!isResize || (IS_IPHONE && !isOrientationChange)) {
      $("#control").css("left", isFlipped
        ? (window.innerWidth * 0.05)
        : window.innerWidth - $("#control").width() - (window.innerWidth * 0.05));
    }
  }

  ////
  // Keypress handling
  ////////

  $(window).keydown(function(e) {
    KEYS_DOWN[e.which]++;

    // Multi-keypress
    if (Object.keys(KEYS_DOWN).length > 1) {
      if ((18 in KEYS_DOWN) && // Option
          (37 in KEYS_DOWN)) { // Left cursor
        CONTROL.seekBack();
      }
      else if ((18 in KEYS_DOWN) && // Option
               (39 in KEYS_DOWN)) { // Right cursor
        CONTROL.seekForward();
      }
      else if ((93 in KEYS_DOWN) && // Command
               (37 in KEYS_DOWN)) { // Left cursor
        history.back();
      }
      // Clear out all keypresses except for the Option
      // key to allow Option to be held whilst pressing
      // Left or Right repeatedly
      for (x in KEYS_DOWN) {
        if (x != 18) delete KEYS_DOWN[x];
      }
    }
    // Otherwise single keypress
    else {
      switch(e.which) {
        case 32: // Spacebar
        case 40: // Down cursor
          $("#play-pause").click();
          break;

        case 37: // Left cursor
          $("#speed-down").click();
          break;

        case 39: // Right cursor
          $("#speed-up").click();
          break;

        default:
          isHandled = false;
      }
    }
    return false; // Never propogate the keypress up
  });

  $(window).keyup(function(e) {
    delete KEYS_DOWN[e.which];
  });

  $(window).bind("orientationchange", function() {
    positionControl(false, true, CONTROL.isFlipped());
  });

  $(window).bind("resize", function() {
    resizeVideo();
    positionControl(true, false, CONTROL.isFlipped());
  });

  </script>
  <body>
    <div id="fullscreen">
      <video id="video" type="video/mp4" playsinline autoplay muted controls></video>
      <div id="control">
        <div class="button-group">
          <div id="speed-down" class="button" onclick="CONTROL.speedDown(this)">&lt;&lt;</div>
          <div id="play-pause" class="button" onclick="CONTROL.togglePlayPause(this)">Pause</div>
          <div id="speed-up" class="button" onclick="CONTROL.speedUp(this)">&gt;&gt;</div>
        </div>
        <div class="button-group">
          <div id="prev-cam" class="button" onclick="CONTROL.prevCam(this)">Prv</div>
          <div id="play-state"></div>
          <div id="next_cam" class="button" onclick="CONTROL.nextCam(this)">Nxt</div>
        </div>
        <div id="entries"></div>
        <div class="button-group" id="iphone-buttons">
          <div id="seek-back" class="button" onclick="CONTROL.seekBack(this)">|&lt;&lt;</div>
          <div id="flip-position" class="button" onclick="CONTROL.reposition(this)">Repo</div>
          <div id="seek-forward" class="button" onclick="CONTROL.seekForward(this)">&gt;&gt;|</div>
        </div>
      </div>
    </div>
  </body>
</html>